module main // must be named same as the file! 

import src/lib
import string/tty
import char
import option
import list
import io/filesystem
import string
import io
import io/error
import io/console
import exception

// Helper functions
//////////////////////////////////////////////////////////////////////////////////////////////////

//convert string to list of characters
def toCharList(str: String): List[Char] = {
  def go(index: Int): List[Char] = {
    with on[OutOfBounds].panic;
    if (index >= str.length) {
      []
    } else {
      val c = str.charAt(index)
      Cons(c, go(index + 1))
    }
  }
  go(0)
}

// Convert file letter (a-h) to index (0-7)
def fileToIndex(file: Char): Int = 
  file.toInt - 'a'.toInt

// Convert rank number (1-8) to index (0-7) 
def rankToIndex(rank: Char): Int =
  8 - (rank.toInt - '0'.toInt)

/// Map a function `f` over elements in a given list, providing both the index and element.
def mapWithIndex[A, B](l: List[A]) { f: (Int, A) => B }: List[B] = {
  var acc = Nil[B]()
  var i = 0
  l.foreach { el => 
    acc = Cons(f(i, el), acc)
    i = i + 1
  }
  acc.reverse
}


// Types and Data Structures
type Piece {
  King(white: Bool)
  Queen(white: Bool)
  Rook(white: Bool)
  Bishop(white: Bool)
  Knight(white: Bool)
  Pawn(white: Bool)
}

record Board(cells: List[List[Option[Piece]]])

record Puzzle(moves: List[String], board: Board, playWhite: Bool)


// Moving pieces
//////////////////////////////////////////////////////////////////////////////////////////////////
 
// Make a single move on the board
def makeMove(board: Board, move: String): Board = {

  with on[OutOfBounds].panic
  // Convert algebraic notation
  val fromFile = fileToIndex(move.charAt(0))
  val fromRank = rankToIndex(move.charAt(1))
  val toFile = fileToIndex(move.charAt(2))
  val toRank = rankToIndex(move.charAt(3))

  // Get the moving piece
  val piece = list::get(list::get(board.cells, fromRank), fromFile)

  // Create new board with updated positions
  val newCells = board.cells.mapWithIndex { (r, rank) =>
    rank.mapWithIndex { (f, square) =>
      if (r == fromRank && f == fromFile) {
        None() // Clear source square
      } else if (r == toRank && f == toFile) {
        piece // Place piece at destination
      } else {
        square
      }
    }
  }
  
  Board(newCells)
}

def minimalWorkingProduct(puzzle: Puzzle): Unit = {
  def toMove (white: Bool): String = {if (white) "(White)" else "(Black)"}

  var board = puzzle.board
  var whiteToMove = puzzle.playWhite
  println("start ------------------------")
  var turn = 0
  printBoard(puzzle.board)
  puzzle.moves.foreach { move =>
    if (turn.mod(2) == 0) {
      println("Enemies turn. " ++ toMove(whiteToMove) ++ " he moved: " ++ move)
      board = makeMove(board, move)
      printBoard(board)
    } else {
      println("Your turn. " ++ toMove(whiteToMove))
      with console;
      do writeLine("Enter a move: ") 
      val input = do readLine()       
      println("You entered: " ++ input)
      if (input == move) {
        board = makeMove(board, move)
      }
      else {
        with on[OutOfBounds].panic
        println("Wrong move. You have one more chance.")
        println("Tipp: you have to move the piece on " ++ move.substring(0, 2))
        do writeLine("Enter a move: ") 
        val input = do readLine()       
        println("You entered: " ++ input)
        if (input == move) {
          board = makeMove(board, move)
        }
        else {
          println("You lost. The correct move was: " ++ move)
          return
          ()
        }
      }
      printBoard(board)
    }
    whiteToMove = not(whiteToMove)
    turn = turn + 1
  }
  println("You won!")
  println("end   ------------------------")

}


// FEN parsing
//////////////////////////////////////////////////////////////////////////////////////////////////
/// 
def fenToColor(fen: String): Bool = {
  with on[OutOfBounds].panic;
  
  val fields = fen.split(" ")
  val turn = list::get(fields, 1)
  
  return turn == "w"
}

def fenToBoard(fen: String): Board = {

  def charToPiece(c: Char): Piece = {  
    c match {    
      case 'K' => King(true)
      case 'Q' => Queen(true)
      case 'R' => Rook(true)
      case 'B' => Bishop(true)
      case 'N' => Knight(true)
      case 'P' => Pawn(true)
      case 'k' => King(false)
      case 'q' => Queen(false)
      case 'r' => Rook(false)
      case 'b' => Bishop(false)
      case 'n' => Knight(false)
      case 'p' => Pawn(false)
      case _ => King(true) //TODO throw error
    }
  }

  def processRank(rank: String): List[Option[Piece]] = {
    var result = []
    val charList = toCharList(rank)
    // Process each character
    charList.foreach { c =>
      if (c >= '1' && c <= '8') {
        val emptyCount = c.toInt - '0'.toInt
        var i = 0
        while (i < emptyCount) {
          result = Cons(None(), result)
          i = i + 1
        }
      } else {
        val piece = charToPiece(c)
        result = Cons(Some(piece), result)
        ()
      }
    }
    return result.reverse()
  } 

  with on[OutOfBounds].panic; //TODO NOT NICE

  val placement = fen.split(" ").get(0) //get moves
  val ranks = placement.split("/") // Split into ranks (rows)

  Board([
        processRank(list::get(ranks, 0)), 
        processRank(list::get(ranks, 1)), 
        processRank(list::get(ranks, 2)), 
        processRank(list::get(ranks, 3)), 
        processRank(list::get(ranks, 4)), 
        processRank(list::get(ranks, 5)), 
        processRank(list::get(ranks, 6)), 
        processRank(list::get(ranks, 7))])
  //TODO WITH MAP?
}


// printing
//////////////////////////////////////////////////////////////////////////////////////////////////
val whiteBg = "◻️"
val blackBg = "◼️"


def printBoard(board: Board): Unit = {
  var linebreak = 0
  var isWhite = false;
  val tblack = "\u001b[34m"    // Black text
  val twhite = "\u001b[37m"    // White text 
  val reset = "\u001b[0m"

  def pieceToSymbol(piece: Option[Piece]): String = {
    if (linebreak.mod(8) == 0){isWhite = not(isWhite)}
    linebreak = linebreak + 1
    isWhite = not(isWhite)

    piece match {
      case None() => if (isWhite) {blackBg} else whiteBg
      case Some(King(white)) => if (white) twhite ++ "♔" ++ reset else tblack ++ "♔" ++ reset
      case Some(Queen(white)) => if (white) twhite ++ "♕" ++ reset else tblack ++ "♕" ++ reset
      case Some(Rook(white)) => if (white) twhite ++ "♖" ++ reset else tblack ++ "♖" ++ reset
      case Some(Bishop(white)) => if (white) twhite ++ "♗" ++ reset else tblack ++ "♗" ++ reset
      case Some(Knight(white)) => if (white) twhite ++ "♘" ++ reset else tblack ++ "♘" ++ reset
      case Some(Pawn(white)) => if (white) twhite ++ "♙" ++ reset else tblack ++ "♙" ++ reset
    }
  }
  println("     a b c d e f g h")
  println("  ------------------")
  val rows = board.cells.map { row =>
    row.map { cell =>
      pieceToSymbol(cell)
      
    }.join(" ")
  }
  var counter = 8
  rows.foreach { row =>
    println(show(counter) ++ " | " ++ row)
    counter = counter - 1
  }
  println(" ")
}



/**
def getRandomLine(str: String): List[Option[Int]] = {
  // Split by both Windows and Unix line endings
  val lines = str.string::split("\n")

  if (lines.length == 0) {
    return [None(), None(), None()]
  }
  
  // Handle empty string case
  // Get random index between 0 and lines.length - 1
  val randomIndex = (random() * lines.length.toDouble).toInt
  val randomIndex1 = (random() * lines.length.toDouble).toInt
  val randomIndex2 = (random() * lines.length.toDouble).toInt
  return [Some(randomIndex), Some(randomIndex1), Some(randomIndex2)]

}**/





def main() = {

  println("start◻️")





  with on[IOError].panic; 
  
  with filesystem;        

  //val content = readFile("1.csv")
  //println(content.string::split("\n"))
   
  //var b1 = fenToBoard("2r3kR/Q7/5q2/1brpN3/5Pp1/4P1P1/6K1/1B6 b KQkq - 0 12")
  // b - - 2 43,f6h8 a7f7
  //printBoard(b1)
  //b1 = makeMove(b1, "f6h8")
  //printBoard(b1)
  var p = Puzzle(["f6h8", "a7f7"], fenToBoard("2r3kR/Q7/5q2/1brpN3/5Pp1/4P1P1/6K1/1B6 b - - 2 43"), fenToColor("2r3kR/Q7/5q2/1brpN3/5Pp1/4P1P1/6K1/1B6 b - - 2 43"))
  minimalWorkingProduct(p)
  //var b1 = fenToBoard("8/8/8/8/8/8/8/8 b - - 2 43")
  //var b2 = fenToBoard("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1")
  //printBoard(b2)
  

  println("end")
  
}